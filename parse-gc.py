#! /usr/bin/env python
"""
 Version: 0.9
 Requires: sys, optparse
 Date: 2011-12-04 13:38
 Author: Andreas Paul
"""

desc = """Parse and record gc logs generated by the JVM.
If the java pid argument is given it will also jstat the old and perm
memory utilization using OGMX and PGMX."""

epilog = """Example call:
%prog -f gc.log
or
%prog -f gc.log -P 5000
or
%prog -f gc.log -p `pgrep java` -P 5000"""

import sys
from optparse import OptionParser

from lib import *

def main():
    """ Parse gc logs generated by the JVM

    Desc:
        Will print GC metrics in JSON format for every line it can parse.
        If the java pid argument is given it will also jstat the old and perm
        memory utilization using OGMX and PGMX.
        jstat calls can be skipped if the URI in the GET 
            requests contains jstat=0
        Collected data can be cleared if the URI in the GET 
            requests contains reset=1

    Args:
        None

    Returns:
        0: If everything is OK
    """

    usage = 'usage: %prog -f LOGILE [-P PORT|-p PID]'
    parser = OptionParser(usage, version="%prog 0.9",
                                description=desc)

    parser.add_option('-f', '--logfile', dest='logfile',
                    help='GC logfile you want to follow and parse')
    parser.add_option('-P', '--port', dest='port', default='5000', type='int',
                    help='port at which the HTTP server will run')
    parser.add_option('-p', '--pid', dest='pid', type='int',
                    help='pid of java process for jstat calls')

    (options, args) = parser.parse_args()

    # Making sure all mandatory options appeared.
    mandatories = {'logfile': 'f'}

    for m in mandatories:
        if not options.__dict__[m]:
            print ('mandatory option -%s for %s is missing! Try --help' % (
                    mandatories[m], m))
            sys.exit(1)

    t = Tailer.Tailer(options.logfile)
    p = Parser.Parser()
    if options.pid:
        p.setPid(options.pid)
    s = Server.Server(options.port, p, t)

    try:
        s.serve()
    except (KeyboardInterrupt, SystemExit):
        print "exiting main..."
        sys.excepthook(*sys.exc_info())

    return 0


if __name__ == '__main__' or __name__ == sys.argv[0]:
    try:
        sys.exit(main())    # call main subroutine
    except Exception, e:
        print e

